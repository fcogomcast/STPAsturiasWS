
package es.tributasenasturias.services.ws.archivodigital;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.annotation.Resource;
import javax.jws.HandlerChain;
import javax.jws.WebService;
import javax.xml.ws.BindingType;
import javax.xml.ws.Holder;
import javax.xml.ws.WebServiceContext;

import es.tributasenasturias.services.ws.archivodigital.ades.PadesSigner;
import es.tributasenasturias.services.ws.archivodigital.bd.Datos;
import es.tributasenasturias.services.ws.archivodigital.utils.CompresionGZIP;
import es.tributasenasturias.services.ws.archivodigital.utils.GeneradorCSV;
import es.tributasenasturias.services.ws.archivodigital.utils.ImpresorCSV;
import es.tributasenasturias.services.ws.archivodigital.utils.SignerChecker;
import es.tributasenasturias.services.ws.archivodigital.utils.VerificadorFirmaCertificado;
import es.tributasenasturias.services.ws.archivodigital.utils.GeneradorCSV.DatosCSV;
import es.tributasenasturias.services.ws.archivodigital.utils.Preferencias.Preferencias;
import es.tributasenasturias.services.ws.archivodigital.utils.log.Logger;
import es.tributasenasturias.servicios.firmasades.FormatoPadesType;
/* INIPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
import es.tributasenasturias.services.ws.archivodigital.utils.Base64;
/* FINPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
/* INIPETITRIBUTAS-88 MCMARCO ** 28/04/2020 ** Formato XML del expediente electrónico */
//import org.w3c.dom.Node;
/* FINPETITRIBUTAS-88 MCMARCO ** 28/04/2020 ** Formato XML del expediente electrónico */

/**
 * This class was generated by the JAX-WS RI.
 * Oracle JAX-WS 2.1.3-06/19/2008 07:03 PM(bt)
 * Generated source version: 2.1
 * 
 */
@WebService(portName = "ArchivoDigitalSOAP", serviceName = "ArchivoDigital", targetNamespace = "http://ArchivoDigital.ws.services.tributasenasturias.es/ArchivoDigital/", wsdlLocation = "/wsdls/ArchivoDigital.wsdl", endpointInterface = "es.tributasenasturias.services.ws.archivodigital.ArchivoDigital")
@BindingType("http://schemas.xmlsoap.org/wsdl/soap/http")
@HandlerChain(file="HandlerChain.xml")
public class ArchivoDigital_ArchivoDigitalSOAPImpl
    implements ArchivoDigital
{


    public ArchivoDigital_ArchivoDigitalSOAPImpl() {
    }
    
    @Resource
  WebServiceContext context;

    // CRUBENCVS 41435. Funcionalidad de generación de datos a custodiar
    private static class DatosCustodia{
    	
    	private DatosCustodia(){
    		
    	}
    	private DatosCustodia(String error){
    		this.esError=true;
    		this.error= error;
    	}
    	
    	private boolean esError;
    	private String codigoUsuario;
    	private String identificador;
    	private String tipoElemento;
    	private String nombreFichero;
    	private String comprimido;
    	private byte[] contenido;
    	private String hashArchivo;
    	private String metadatos;
    	private String firmaCSV;
    	//CRUBENCVS 43599. 21/10/2021  CSV con posición dinámica
    	private Float posXCsv;
    	private Float posYCsv;
    	private Integer[] paginasCsv;
    	//FIN CRUBENCVS 43599
    	private String firmaCertificado;
    	private String firmaExterna;
    	private Date fechaValidezCertificadoFirma;
    	private String csv;
    	private String baseCSV;
    	private String hashFirma;
    	private String nombreFirmante;
    	private String fechaFirma;
    	private String idTransac;
    	private String cargoUsua;
    	private String formatoFirma;
    	private String idArchivoAnterior;
    	private String error;
		public boolean esError() {
			return esError;
		}
		public void setEsError(boolean esError) {
			this.esError = esError;
		}
		public String getCodigoUsuario() {
			return codigoUsuario;
		}
		public void setCodigoUsuario(String codigoUsuario) {
			this.codigoUsuario = codigoUsuario;
		}
		public String getIdentificador() {
			return identificador;
		}
		public void setIdentificador(String identificador) {
			this.identificador = identificador;
		}
		public String getTipoElemento() {
			return tipoElemento;
		}
		public void setTipoElemento(String tipoElemento) {
			this.tipoElemento = tipoElemento;
		}
		public String getNombreFichero() {
			return nombreFichero;
		}
		public void setNombreFichero(String nombreFichero) {
			this.nombreFichero = nombreFichero;
		}
		public String getComprimido() {
			return comprimido;
		}
		public void setComprimido(String comprimido) {
			this.comprimido = comprimido;
		}
		public byte[] getContenido() {
			return contenido;
		}
		public void setContenido(byte[] contenido) {
			this.contenido = contenido;
		}
		public String getHashArchivo() {
			return hashArchivo;
		}
		public void setHashArchivo(String hashArchivo) {
			this.hashArchivo = hashArchivo;
		}
		public String getMetadatos() {
			return metadatos;
		}
		public void setMetadatos(String metadatos) {
			this.metadatos = metadatos;
		}
		public String getFirmaCSV() {
			return firmaCSV;
		}
		public void setFirmaCSV(String firmaCSV) {
			this.firmaCSV = firmaCSV;
		}
		public String getFirmaCertificado() {
			return firmaCertificado;
		}
		public void setFirmaCertificado(String firmaCertificado) {
			this.firmaCertificado = firmaCertificado;
		}
		public String getFirmaExterna() {
			return firmaExterna;
		}
		public void setFirmaExterna(String firmaExterna) {
			this.firmaExterna = firmaExterna;
		}
		public Date getFechaValidezCertificadoFirma() {
			return fechaValidezCertificadoFirma;
		}
		public void setFechaValidezCertificadoFirma(Date fechaValidezCertificadoFirma) {
			this.fechaValidezCertificadoFirma = fechaValidezCertificadoFirma;
		}
		public String getCsv() {
			return csv;
		}
		public void setCsv(String csv) {
			this.csv = csv;
		}
		public String getBaseCSV() {
			return baseCSV;
		}
		public void setBaseCSV(String baseCSV) {
			this.baseCSV = baseCSV;
		}
		public String getHashFirma() {
			return hashFirma;
		}
		public void setHashFirma(String hashFirma) {
			this.hashFirma = hashFirma;
		}
		public String getNombreFirmante() {
			return nombreFirmante;
		}
		public void setNombreFirmante(String nombreFirmante) {
			this.nombreFirmante = nombreFirmante;
		}
		public String getFechaFirma() {
			return fechaFirma;
		}
		public void setFechaFirma(String fechaFirma) {
			this.fechaFirma = fechaFirma;
		}
		public String getIdTransac() {
			return idTransac;
		}
		public void setIdTransac(String idTransac) {
			this.idTransac = idTransac;
		}
		public String getCargoUsua() {
			return cargoUsua;
		}
		public void setCargoUsua(String cargoUsua) {
			this.cargoUsua = cargoUsua;
		}
		public String getFormatoFirma() {
			return formatoFirma;
		}
		public void setFormatoFirma(String formatoFirma) {
			this.formatoFirma = formatoFirma;
		}
		public String getError() {
			return error;
		}
		public void setError(String error) {
			this.error = error;
		}
		public String getIdArchivoAnterior() {
			return idArchivoAnterior;
		}
		public void setIdArchivoAnterior(String idArchivoAnterior) {
			this.idArchivoAnterior = idArchivoAnterior;
		}
		public Float getPosXCsv() {
			return posXCsv;
		}
		public void setPosXCsv(Float posXCsv) {
			this.posXCsv = posXCsv;
		}
		public Float getPosYCsv() {
			return posYCsv;
		}
		public void setPosYCsv(Float posYCsv) {
			this.posYCsv = posYCsv;
		}
		public Integer[] getPaginasCsv() {
			return paginasCsv;
		}
		public void setPaginasCsv(Integer[] paginasCsv) {
			this.paginasCsv = paginasCsv;
		}
    }
    /**
     * Prepara los datos para la custodia, en función de los datos de entrada al 
     * servicio. Algunos de los datos pueden haberse modificado, mientras que otros
     * pueden ser los mismos que a la entrada. Eso es transparente para la función de custodia.
     * Es una copia exacta de lo que antes era custo"custodia", excepto por la parte de la custodia en sí
     * He dejado los log porque, ya que se hacían aquí, aquí se quedan.
     * @param codigoUsuario
     * @param identificador
     * @param tipoElemento
     * @param nombreFichero
     * @param comprimido
     * @param archivo
     * @param hashArchivo
     * @param metadatos
     * @param firma
     * @return {@link DatosCustodia} con los datos a usar en la custodia
     * @throws Exception
     */
    private DatosCustodia prepararDatosCustodia(String codigoUsuario, 
    		                           	        String identificador, 
    		                                    String tipoElemento, 
    		                                    String nombreFichero, 
    		                                    String comprimido, 
    		                                    byte[] archivo, 
    		                                    String hashArchivo, 
    		                                    String metadatos, 
    		                                    FirmaType firma,
    		                                    String idArchivoAnterior,
    		                                    String idLlamada,
    		                                    Preferencias pref,
    		                                    Logger logger
    								   ) throws Exception{
    	DatosCustodia dc = new DatosCustodia();
		String error = "";

		Datos datos = new Datos();
		String firmaCSV = "";
		String firmante = "";
		String firmaExterna = "";
		String firmaCertificado = "";
		String ltv = "";
		//CRUBENCVS 43599 21/10/2021 Posición dinámica de CSV
		List<Integer> paginas= new ArrayList<Integer>();
		Float posXCsv= null;
		Float posYCsv = null;
		//FIN CRUBENCVS 43599
		logger.info("codigoUsuario:" + codigoUsuario);
		logger.info("identificador:" + identificador);
		logger.info("nombreFichero:" + nombreFichero);
		logger.info("comprimido:" + comprimido);
		logger.info("hashArchivo:" + hashArchivo);
		if (SignerChecker.admiteFirmaCSV(nombreFichero)
				|| SignerChecker.admiteFirmaCertificado(nombreFichero)) {
			if (firma != null) {
				if (firma.getCSV() != null) {
					firmaCSV = firma.getCSV().getFirmaCSV();
					firmante = firma.getCSV().getFirmante();
					logger.info("firmaCSV:" + firmaCSV);
					logger.info("firmante:" + firmante);
					//CRUBENCVS 43599 21/10/2021
					if (firma.getCSV().getCaracteristicas()!=null){
						CaracteristicasFisicasCSVType cars = firma.getCSV().getCaracteristicas().getFisicas();
						if (cars.getPaginas()!=null){
							StringBuilder pagTxt= new StringBuilder();
							for (PaginaCSVType p:cars.getPaginas().getPagina()){
								//La página 0 no existe, eso es lo único que podemos controlar.
								if (p.getNumero()!= null && p.getNumero()>0){
									paginas.add(p.getNumero());
									pagTxt.append(p.getNumero()).append("-");
								}
							}
							logger.info("Páginas en donde imprimir CSV:"+ pagTxt.toString());
						}
						 if (cars.getPosicion()!=null){
							 posXCsv= cars.getPosicion().getX();
							 posYCsv= cars.getPosicion().getY();
							 logger.info ("Pos X Csv:" + posXCsv);
							 logger.info ("Pos Y Csv:" + posYCsv);
						 }
					}
					//FIN CRUBENCVS 43599

				} else {
					logger.info("Sin bloque CSV");
				}

				if (firma.getCertificado() != null) {
					firmaCertificado = firma.getCertificado().getFirmaCertificado();
					ltv = firma.getCertificado().getLTV();
					logger.info("Firma por certificado:" + firmaCertificado);
					logger.info("Firma LTV:" + ltv);
				} else {
					logger.info("Sin firma por certificado");
				}

				if ("S".equalsIgnoreCase(firmaCertificado)
						|| "S".equalsIgnoreCase(firmaCSV)) {
					logger.info("Sin firma externa, o la firma externa va a ser invalidada");
				} else {
					if (firma.getCertificado() != null) {
						firmaExterna = firma.getFirmaExterna();
						logger.info("Firma Externa:" + firmaExterna);
					}
				}
			} else {
				logger.info("Sin bloque CSV");
				logger.info("Sin firma por certificado");
				logger.info("Sin firma externa");
			}
		} else {
			logger
					.info("El tipo de fichero no admite firma por CSV ni firma por Certificado. Se ignoran los parámetros de firma.");

		}

		String baseCSV = "";
		String existeCsv = "S";
		DatosCSV dCSV = null;
		int cont = 0;
		boolean recomprimir;
		byte[] contenido;
		Date fechaValidezCertificadoFirma = null;
		// Primero comprobamos si el contenido está comprimido. Siempre se
		// supone comprimido en GZIP, así que si lo está operamos con datos
		// descomprimidos,
		// aunque luego guardemos el comprimido.
		if ("S".equalsIgnoreCase(comprimido)) {
			contenido = CompresionGZIP.descomprimir(archivo);
			recomprimir = true;
		} else {
			contenido = archivo;
			recomprimir = false;
		}
		// Intentamos generar el csv, si el csv generado ya existe en la bbdd
		// se vuelve a intentar hasta en 5 ocasiones
		while (existeCsv.equals("S") && (cont < 5)) {
			try {
				// Generamos el csv
				logger.info("Iniciamos la generación del CSV...");
				// csv.value = datos.GenerarCSV(hashArchivo, codigoUsuario,
				// baseCSV);
				dCSV = GeneradorCSV.generarCSV(contenido, firmante, pref);
				logger.info("Generado CSV: " + dCSV.getCSV());
			} catch (Exception ex) {
				logger.error("Error al generar el CSV por: " + ex.getMessage());
			}

			if (cont > 0)
				logger.info("Comprobando si el CSV existe. " + (cont + 1)
						+ " INTENTO ...");
			else
				logger.info("Comprobando si el CSV existe ...");

			existeCsv = datos.ExisteCsv(dCSV.getCSV());

			if (existeCsv.equals("S")) {
				logger.info("El csv generado ha resultado estar repetido, vamos a proceder a su regeneración.");
				if (cont == 4) {
					error = "Tras 5 intentos, no se ha podido generar un CSV único.";
					return new DatosCustodia(error);
				}
			}
			cont++;
		}
		// En cualquier caso, el baseCSV es el calculado.
		if (dCSV != null) // No veo cómo podría ser null aquí, a menos que no
							// calculemos el CSV
		{
			baseCSV = dCSV.getBaseCSV();
		}
		/* INIPETITRIBUTAS-5 ENAVARRO ** 09/09/2020 ** Compulsa */
		//CRUBENCVS 48601 18/08/2023. El firmante por defecto no es el código de usuario
		//String nombreFirmante = firmante != null ? firmante : codigoUsuario;
		String nombreFirmante = firmante != null && !"".equals(firmante) ? firmante : pref.getNombreFirmanteDefecto();
		//FIN CRUBENCVS 48601
		/* FINPETITRIBUTAS-5 ENAVARRO ** 09/09/2020 ** Compulsa */
		// Si se trata de un tipo soportado, se le añadirá el CSV en cada
		// página.
		if ("S".equalsIgnoreCase(firmaCSV)) {
			if (SignerChecker.admiteFirmaCSV(nombreFichero)) {
				//CRUBENCVS 43599.  Añadidos parámetros posXCsv, posYCsv y paginas
				contenido = ImpresorCSV.addPdfCsv(
											contenido,
											pref.getTextoCsv(), 
											dCSV.getCSV(),
											posXCsv,
											posYCsv,
											paginas
											);
				// FIN CRUBENCVS  43599
			} else {
				// Lo paramos, porque nos indican que hay que firmar y sin
				// embargo no se puede
				error = "Se ha indicado que se quiere firmar el documento, pero el tipo de archivo no está soportado en la firma";
				return new DatosCustodia(error);
			}
		}
		/* INIPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
		byte[] contenidoFirma = null;
		String formatoFirma = "urn:afirma:dss:1.0:profile:XSS:forms:PDF";
		String hashFirma = "";
		/* INIPETITRIBUTAS-5 ENAVARRO ** 07/09/2020 ** Compulsa */
		// String nombreFirmante = "";
		/* FINPETITRIBUTAS-5 ENAVARRO ** 07/09/2020 ** Compulsa */
		String fechaFirma = "";
		String idTransac = "";
		String cargoUsua = "";
		/* FINPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
		// Firma por certificado, siempre después de la del CSV
		if ("S".equalsIgnoreCase(firmaCertificado)) {
			if (SignerChecker.admiteFirmaCertificado(nombreFichero)) {
				PadesSigner signer = PadesSigner.newInstance(pref, idLlamada);
				if ("S".equalsIgnoreCase(ltv)) {
					/* INIPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
					/*
					 * contenido= signer.firmar(contenido,
					 * FormatoPadesType.LTV);
					 */
					/*
					 * INIPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de
					 * sello de tiempo
					 */
					// contenidoFirma= signer.firmar(contenido,
					// FormatoPadesType.LTV);
					contenidoFirma = signer.firmar(contenido,
							FormatoPadesType.LTV, true);
					/*
					 * FINPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de
					 * sello de tiempo
					 */
					/* FINPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
				} else {
					/* INIPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
					/*
					 * contenido= signer.firmar(contenido,
					 * FormatoPadesType.EPES);
					 */
					/*
					 * INIPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de
					 * sello de tiempo
					 */
					// contenidoFirma= signer.firmar(contenido,
					// FormatoPadesType.EPES);
					contenidoFirma = signer.firmar(contenido,
							FormatoPadesType.EPES, true);
					/*
					 * FINPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de
					 * sello de tiempo
					 */
					/* FINPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
				}
				/* INIPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
				/* fechaValidezCertificadoFirma=VerificadorFirmaCertificado.getFechaValidezCertificadoFirma(contenido); */
				fechaValidezCertificadoFirma = VerificadorFirmaCertificado
						.getFechaValidezCertificadoFirma(contenidoFirma);
				// Rellenamos los valores de la firma de custodiar
				hashFirma = String.valueOf(Base64.encode(contenidoFirma));
				/* INIPETITRIBUTAS-5 ENAVARRO ** 09/09/2020 ** Compulsa */
				// nombreFirmante = codigoUsuario;
				/* FINPETITRIBUTAS-5 ENAVARRO ** 09/09/2020 ** Compulsa */
				fechaFirma = GeneradorCSV.obtenerFechaActual();
				idTransac = "";
				cargoUsua = "";
				logger.info("Petición custodia firma desde custodia archivo");
				logger.info("hashFirma:" + hashFirma);
				logger.info("nombreFirmante:" + nombreFirmante);
				logger.info("fechaFirma:" + fechaFirma);
				logger.info("idTransac:" + idTransac);
				logger.info("cargoUsua:" + cargoUsua);
				logger.info("formatoFirma:" + formatoFirma);
				/* FINPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
			} else {
				// Lo paramos, porque nos indican que hay que firmar y sin
				// embargo no se puede
				error = "Se ha indicado que se quiere firmar el documento, pero el tipo de archivo no está soportado en la firma";
				return new DatosCustodia(error);
			}
		} else if ("S".equalsIgnoreCase(firmaExterna)) {
			// Firma Externa sólo tendrá "S" si no se ha firmado por CSV o por
			// Certificado, porque estas la invalidan.
			if (SignerChecker.admiteFirmaCertificado(nombreFichero)) {
				fechaValidezCertificadoFirma = VerificadorFirmaCertificado
						.getFechaValidezCertificadoFirma(contenido);
			}
		}
		// Generamos el hash en todo caso, con lo que tenga el contenido actual.
		hashArchivo = GeneradorCSV.getStringHash(contenido, pref
				.getAlgoritmoHashArchivo());
		// Si estaba comprimido en entrada, hemos de comprimirlo de nuevo.
		if (recomprimir) {
			contenido = CompresionGZIP.comprimir(contenido);
		}
        
		dc.setCodigoUsuario(codigoUsuario);
		dc.setIdentificador(identificador);
		dc.setTipoElemento(tipoElemento);
		dc.setNombreFichero(nombreFichero);
		dc.setComprimido(comprimido);
		dc.setContenido(contenido);
		dc.setHashArchivo(hashArchivo);
		dc.setMetadatos(metadatos);
		dc.setFirmaCSV(firmaCSV);
		dc.setFirmaCertificado(firmaCertificado);
		dc.setFirmaExterna(firmaExterna);
		dc.setFechaValidezCertificadoFirma(fechaValidezCertificadoFirma);
		dc.setCsv(dCSV.getCSV());
		dc.setBaseCSV(baseCSV);
		dc.setHashFirma(hashFirma);
		dc.setNombreFirmante(nombreFirmante);
		dc.setFechaFirma(fechaFirma);
		dc.setIdArchivoAnterior(idArchivoAnterior);
		dc.setIdTransac(idTransac);
		dc.setCargoUsua(cargoUsua);
		dc.setFormatoFirma(formatoFirma);
		//CRUBENCVS 43599 21/10/2021. Esto una vez aquí ya no se utiliza, pero así tenemos los datos que se utilizaron.
		dc.setPosXCsv(posXCsv);
		dc.setPosYCsv(posYCsv);
		dc.setPaginasCsv(paginas.toArray(new Integer[20]));
		//FIN CRUBENCVS 43599
		dc.setEsError(false);
        
        return dc;    
        
      
    }
    /**
	 * 
	 * @param error
	 * @param hash
	 * @param codigoUsuario
	 * @param archivo
	 * @param identificador
	 * @param nombreFichero
	 * @param hashArchivo
	 * @param idArchivo
	 * @param tipoElemento
	 * @param csv
	 * @param comprimido
	 * @param metadatos
	 * @param firma
	 */
    public void custodia(String codigoUsuario, String identificador, String tipoElemento, String nombreFichero, String comprimido, byte[] archivo, 
    		String hashArchivo, String metadatos, FirmaType firma, Holder<Integer> idArchivo, Holder<String> csv, Holder<String> hash, Holder<String> error) {
        Logger logger = null;
        try 
        {
      	  String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
      	  Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
      	  if (pref==null) {
      		  throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
      	  }
      	  logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
      	  logger.info("Petición custodia archivo");
      	  Datos datos = new Datos();
      	  DatosCustodia dc = prepararDatosCustodia(codigoUsuario, 
      			  								   identificador, 
      			  								   tipoElemento, 
      			  								   nombreFichero, 
      			  								   comprimido, 
      			  								   archivo, 
      			  								   hashArchivo,
      			  								   metadatos, 
      			  								   firma, 
      			  								   null,
      			  								   idLlamada, 
      			  								   pref, 
      			  								   logger);		
      	
      	/*
      	 * datos.CustodiaArchivo(codigoUsuario, identificador, 
                    tipoElemento, nombreFichero, 
                    comprimido, contenido, 
                    hashArchivo, metadatos, 
                    firmaCSV,
                    firmaCertificado,
                    firmaExterna,
                    fechaValidezCertificadoFirma,
                    dCSV.getCSV(), 
                    baseCSV, 
                    hashFirma, nombreFirmante, fechaFirma, idTransac, cargoUsua, formatoFirma,
                    idArchivo, error);
      	 */
        datos.CustodiaArchivo(dc.getCodigoUsuario(), 
        					  dc.getIdentificador(), 
                              dc.getTipoElemento(), 
                              dc.getNombreFichero(), 
                              dc.getComprimido(), 
                              dc.getContenido(), 
                              dc.getHashArchivo(), 
                              dc.getMetadatos(), 
                              dc.getFirmaCSV(),
                              dc.getFirmaCertificado(),
                              dc.getFirmaExterna(),
                              dc.getFechaValidezCertificadoFirma(),
                              dc.getCsv(), 
                              dc.getBaseCSV(), 
                              /* INIPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
                              dc.getHashFirma(), 
                              dc.getNombreFirmante(), 
                              dc.getFechaFirma(), 
                              dc.getIdTransac(), 
                              dc.getCargoUsua(), 
                              dc.getFormatoFirma(),
                              /* FINPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
                              idArchivo, 
                              error);
            
        if(dc.esError()){
          error.value= dc.getError();
          logger.error("ERROR:" + error.value);
          csv.value="";
        }
        else
          csv.value=dc.getCsv();
        
        /* INIPETITRIBUTAS-5 ENAVARRO ** 21/12/2020 ** Compulsa */
        hash.value = dc.getHashArchivo();
        /* FINPETITRIBUTAS-5 ENAVARRO ** 21/12/2020 ** Compulsa */
        logger.info("Salida: idArchivo(" + idArchivo.value + "), csv(" + csv.value + ")");
        logger.info("FIN - Documento custodiado correctamente");
      } catch (Exception e)
      {
        if (logger!=null) {
          logger.error("Error en custodia de documento en Archivo Digital:" + e.getMessage());
          if (idArchivo.value!=null && idArchivo.value!=0) {
            logger.info("Salida: idArchivo(" + idArchivo.value + "), csv(" + csv.value + ")");
            logger.info("FIN - Documento custodiado correctamente");
          } else {
            logger.info("FIN - Documento no custodiado.");
          }
        }
        else {
          System.err.println ("Error en custodia de documento en Archivo Digital " + e.getMessage());
            e.printStackTrace();
        }
        error.value= "Error en proceso de archivo digital:" + e.getMessage();
      }
    }

    /**
     * 
     * @param error
     * @param archivo
     * @param obtenerSoloDatosArchivo
     * @param idArchivo
     * @param datosArchivo
     * @param codigoUsuario
     */
    public void obtieneArchivoPorId(String codigoUsuario, int idArchivo, String obtenerSoloDatosArchivo, Holder<byte[]> archivo, 
        Holder<String> datosArchivo, Holder<String> error) {
    	Logger logger = null;
        try {
          String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
          Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
          if (pref==null) {
            throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
          }
          logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
          logger.info("Petición Obtiene archivo");
          logger.info("codigoUsuario:" + codigoUsuario);
          logger.info("idArchivo:" + idArchivo);
          
          Datos datos = new Datos();
          datos.obtieneArchivo(codigoUsuario, idArchivo, obtenerSoloDatosArchivo,datosArchivo, archivo, error);
      
          logger.info("datosArchivo:" + datosArchivo.value);
          if(error.value!="" && error.value!=null)
            logger.error("ERROR:" + error.value);
          
          return;
        }
        catch (Exception e) {
          logger.error("Error en obtención de documento mediante id en Archivo Digital:" + e.getMessage());
          error.value= "Error en obtención de archivo digital:" + e.getMessage();
        }
    }

    /**
     * 
     * @param error
     * @param archivo
     * @param csv
     * @param datosArchivo
     * @param codigoUsuario
     */
    public void obtieneArchivoPorCsv(String codigoUsuario, String csv, Holder<byte[]> archivo, Holder<String> datosArchivo, Holder<String> error) {
    	Logger logger = null;
        try {
          String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
          Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
          if (pref==null) {
            throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
          }
          logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
          logger.info("Petición Obtiene archivo Por CSV");
          logger.info("codigoUsuario:" + codigoUsuario);
          logger.info("Csv:" + csv);
          Datos datos = new Datos();
          datos.obtieneArchivoPorCSV(codigoUsuario, csv, datosArchivo, archivo, error);
      
          logger.info("datosArchivo:" + datosArchivo.value);
          if(error.value!="" && error.value!=null)
            logger.error("ERROR:" + error.value);
          
          return;
        } catch (Exception e) {
          error.value= "Error inesperado en la recuperación de archivo por CSV:"+ e.getMessage();
        }
    }

    /**
     * 
     * @param error
     * @param archivo
     * @param existeArchivo
     * @param listaArchivos
     * @param codigoUsuario
     */
    public void existeArchivo(String codigoUsuario, byte[] archivo, Holder<String> existeArchivo, Holder<ListaArchivosType> listaArchivos, 
        Holder<String> error) {
    	Logger logger = null;
        try{
          String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
          Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
          if (pref==null) {
            throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
          }
          logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
          logger.info("Petición Existe Archivo");
          logger.info("codigoUsuario:" + codigoUsuario);
          //Generamos el hash
          if (archivo==null) {
            error.value="No se ha recibido un archivo";
          }
          String hashArchivo= GeneradorCSV.getStringHash(archivo, pref.getAlgoritmoHashArchivo());
          logger.info("Hash:" + hashArchivo);
          Datos datos = new Datos();
          datos.existeArchivoHash(codigoUsuario, hashArchivo, existeArchivo, listaArchivos, error);
      
          logger.info("existeArchivo:" + existeArchivo.value);
          if(error.value!="" && error.value!=null)
          logger.error("ERROR:" + error.value);
          
          return;
        } catch (Exception e) {
          error.value= "Error inesperado en la comprobación de existencia de archivo:"+ e.getMessage();
        }
    }

    /**
     * INIPETITRIBUTAS-23 ENAVARRO ** 05/11/2019 ** Frontend portafirmas
     * Esta clase custodia una firma usando la funcion PL GUARDARFIRMA del paquete ARCHIVO_DIGITAL.
     * @author: Eduardo Navarro Poveda
     * FINPETITRIBUTAS-23 ENAVARRO ** 05/11/2019 ** Frontend portafirmas
     * @param metadatosFirma
     * @param idadar
     * @param error
     * @param hashFirma
     * @param tipoFirma
     * @param formatoFirma
     * @param datosArchivo
     * @param idTransac
     * @param codigoUsuario
     * @param generaCsv
     * @param idFirmaExt
     * @param fechaFirmaHuella
     * @param cargoUsua
     * @param base
     * @param nombreFirmante
     * @param fechaFirma
     */
    public void custodiaFirma(String codigoUsuario, int idadar, String hashFirma, String nombreFirmante, String fechaFirma, 
        String idTransac, String cargoUsua, String generaCsv, String formatoFirma, String metadatosFirma, String base, String tipoFirma, 
        String idFirmaExt, String fechaFirmaHuella, Holder<String> datosArchivo, Holder<String> error) {
    	Logger logger = null;
        try 
        {
          String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
          Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
          if (pref==null) {
            throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
          }
          logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
          Datos datos = new Datos();
          logger.info("Petición custodia firma");
          logger.info("codigoUsuario:" + codigoUsuario);
          logger.info("idadar:" + idadar);
          logger.info("hashFirma:" + hashFirma);
          logger.info("nombreFirmante:" + nombreFirmante);
          logger.info("fechaFirma:" + fechaFirma);
          logger.info("idTransac:" + idTransac);
          /* INIPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
          /* logger.info("justificanteFirma:" + justificanteFirma); */
          /* FINPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
          logger.info("cargoUsua:" + cargoUsua);
          logger.info("generaCsv:" + generaCsv);
          logger.info("formatoFirma:" + formatoFirma);
          logger.info("metadatosFirma:" + metadatosFirma);
          logger.info("base:" + base);
          logger.info("tipoFirma:" + tipoFirma);
          logger.info("idFirmaExt:" + idFirmaExt);
          logger.info("fechaFirmaHuella:" + fechaFirmaHuella);
          
          String baseCSV = "";
          String existeCsv = "S";
          DatosCSV dCSV=null;
              int cont = 0;
              // Intentamos generar el csv, si el csv generado ya existe en la bbdd 
              // se vuelve a intentar hasta en 5 ocasiones
              while (generaCsv.equals("S") && (cont < 5))
              {
            try{
              // Generamos el csv
              logger.info("Iniciamos la generación del CSV...");
              //dCSV = datos.GenerarCSV(hashFirma, codigoUsuario, baseCSV);
              dCSV= GeneradorCSV.generarCSV(hashFirma, codigoUsuario, pref);
              logger.info("Generado CSV: " + dCSV.getCSV());        
            }catch(Exception ex)
            {
              logger.error("Error al generar el CSV por: " + ex.getMessage());
            }
            
             if (cont > 0) {
               logger.info("Comprobando si el CSV existe. " + (cont + 1) + " INTENTO ...");
             }
                   else {
                     logger.info("Comprobando si el CSV existe ...");
                   }
             
             existeCsv = datos.ExisteCsv(dCSV.getCSV());
             
             if (existeCsv.equals("S"))
                   {
               logger.info("El csv generado ha resultado estar repetido, vamos a proceder a su regeneración.");
                       if (cont == 4){
                         error.value= "Tras 5 intentos, no se ha podido generar un CSV único.";
                         return;
                       }
                   }
                   cont++;
              }
              //En cualquier caso, el baseCSV es el calculado. 
              if (dCSV!=null) //No veo cómo podría ser null aquí, a menos que no calculemos el CSV
              {
                baseCSV= dCSV.getBaseCSV();
              }
              
          datos.CustodiaFirma(codigoUsuario, idadar, hashFirma, nombreFirmante, fechaFirma, idTransac, 
              /* INIPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
                /* justificanteFirma, cargoUsua, dCSV.getCSV(), formatoFirma, metadatosFirma, baseCSV, tipoFirma, */
                cargoUsua, dCSV.getCSV(), formatoFirma, metadatosFirma, baseCSV, tipoFirma, 
                /* FINPETITRIBUTAS-5 ENAVARRO ** 23/10/2019 ** Compulsa */
                idFirmaExt, fechaFirmaHuella, datosArchivo, error);
              
          logger.info("datosArchivo:" + datosArchivo.value);
          if(error.value!="" && error.value!=null)
            logger.error("ERROR:" + error.value);
          
          return;
        } catch (Exception e)
        {
          error.value= "Error inesperado al custodiar la firma:"+ e.getMessage();
        }
    }

    /* INIPETITRIBUTAS-23 ENAVARRO ** 05/11/2019 ** Frontend portafirmas */
    /**
     * Esta clase firma y custodia un documento configurado para que se realice con sello de organo.
     * @author: Eduardo Navarro Poveda
     * @param firmaPIDF
     * @param idadar
     * @param error
     * @param generaCsv
     * @param cargoUsua
     * @param formatoFirma
     * @param ltv
     * @param nombreFirmante
     * @param datosArchivo
     * @param idTransac
     * @param fechaFirma
     * @param codigoUsuario
     */
    public void firmaServidorYCustodia(String codigoUsuario, int idadar, String nombreFirmante, String fechaFirma, String idTransac, 
        String cargoUsua, String generaCsv, String formatoFirma, String ltv, byte[] firmaPIDF, Holder<String> datosArchivo, Holder<String> error) {
    	Logger logger = null;
        try 
        {
          String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
          Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
          if (pref==null) {
            throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
          }
          logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
          logger.info("Petición Firma servidor y custodia");
          logger.info("codigoUsuario:" + codigoUsuario); 
          logger.info("idadar:" + idadar);
          logger.info("nombreFirmante:" + nombreFirmante);
          logger.info("fechaFirma:" + fechaFirma);
          logger.info("idTransac:" + idTransac);
          logger.info("cargoUsua:" + cargoUsua);
          logger.info("generaCsv:" + generaCsv);
          logger.info("formatoFirma:" + formatoFirma);
          logger.info("ltv:" + ltv);
          logger.info("firmaPIDF:" + firmaPIDF);
          
          // Primero, obtenemos el byte[] del archivo
          Holder<byte[]> contenido = new Holder<byte[]>();
          this.obtieneArchivoPorId(codigoUsuario, idadar, "N", contenido, datosArchivo, error);
          if(error != null && error.value!="" && error.value!=null) {
            logger.error("ERROR al obtener Archivo por Id:" + error.value);
          }
          else {
            // Si han pasado una firmaPIDF, sera porque tiene alguna firma mas, y por tanto se firmara ese base64, 
            // no el de ADAR_ARCHIVOS
            if(firmaPIDF != null && firmaPIDF.length > 0) {
              contenido.value = firmaPIDF;
            }
            // Segundo, hacemos la firma del servidor, dependiendo del valor pasado por ltv: S o N
            byte[] contenidoFirma = null;
                String hashFirma = "";
                PadesSigner signer= PadesSigner.newInstance(pref, idLlamada);
                if ("S".equalsIgnoreCase(ltv))
                {
                  /* INIPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de sello de tiempo */
                  //contenidoFirma= signer.firmar(contenido.value, FormatoPadesType.LTV);
                  contenidoFirma= signer.firmar(contenido.value, FormatoPadesType.LTV, false);
                  /* FINPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de sello de tiempo */
                }
                else {
                  /* INIPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de sello de tiempo */
                  //contenidoFirma= signer.firmar(contenido.value, FormatoPadesType.EPES);
                  contenidoFirma= signer.firmar(contenido.value, FormatoPadesType.EPES, true);
                  /* FINPETITRIBUTAS-24 ENAVARRO ** 08/04/2020 ** Firma de sello de tiempo */
                }

                hashFirma = String.valueOf(Base64.encode(contenidoFirma));
                logger.info("hashFirma:" + hashFirma);

                // Por ultimo, custodiamos la firma
                this.custodiaFirma(codigoUsuario, idadar, hashFirma, nombreFirmante, fechaFirma, idTransac, cargoUsua, generaCsv, formatoFirma, 
                    null, null, null, null, null, datosArchivo, error);
                
                if(error != null && error.value!="" && error.value!=null) {
              logger.error("ERROR al custodiar la firma:" + error.value);
            }
          }
        } catch (Exception e)
        {
          if (logger!=null) {
            logger.error("Error en firma servidor y custodia:" + e.getMessage());
          }
          else {
            System.err.println ("Error en firma servidor y custodia " + e.getMessage());
              e.printStackTrace();
          }
          error.value= "Error en proceso de firma servidor y custodia:" + e.getMessage();
        }
        return;
    }
    /* FINPETITRIBUTAS-23 ENAVARRO ** 05/11/2019 ** Frontend portafirmas */
    /* INIPETITRIBUTAS-88 MCMARCO ** 28/04/2020 ** Formato XML del expediente electrónico */
    /**
     * 
     * @param error
     * @param idArchivo
     * @param metadatos
     * @param datosArchivo
     * @param codigoUsuario
     */
    public void guardarMetadatos(String codigoUsuario, int idArchivo, String metadatos, Holder<String> datosArchivo, Holder<String> error) {
        Logger logger = null;
        try {
	      String idLlamada = (String) context.getMessageContext().get(
	          Constantes.ID_LLAMADA);
	      Preferencias pref = (Preferencias) context.getMessageContext().get(
	          Constantes.PREFERENCIAS);
	      if (pref == null) {
	        throw new Exception(
	            "No se han encontrado las preferencias en el contexto de la llamada");
	      }
	      logger = new Logger(idLlamada, pref.getAppLogDir(), pref
	          .getAppLogFile());
	      logger.info("Petición GuardarMetadatos");
	      logger.info("codigoUsuario:" + codigoUsuario);
	      logger.info("idadar:" + idArchivo);
	      logger.info("metadatos:" + metadatos);
	      Datos datos = new Datos();
	      // Primero, obtenemos el byte[] del archivo
	      Holder<byte[]> contenido = new Holder<byte[]>();
	      String textoError = "";
	      this.obtieneArchivoPorId(codigoUsuario, idArchivo, "N", contenido,
	    		  datosArchivo, error);
	      if (error != null && error.value != "" && error.value != null) {
	    	  textoError+="ERROR al obtener Archivo por Id:" + error.value;
	    	  logger.error(textoError);
	      } else {
	    	  //Document doc=XMLDOMUtils.parseXml(datosArchivo.value);        
	    	  //String metadatosBD = XMLDOMUtils.selectSingleNodeText(doc, "/ROWSET/ROW/Metadatos");
	    	  //if(metadatosBD == null || metadatosBD =="")
	    	  //{
	          datos.GuardarMetadatos(codigoUsuario, idArchivo, metadatos,
	        		  datosArchivo, error);
	          if (error != null && error.value != "" && error.value != null) {
	        	  textoError += "ERROR al guardar los metadatos:"
	        		  + error.value;
	        	  logger.error(textoError);
	          }
	          else
	          {
            
	        	  //Aqui deberiamos de reemplazar los metadatos que se van a devolver por los que se han guardado
	          }
	          //}
	          //else
	          //{
	          //  textoError += "El archivo custodiado ya tiene metadatos";
	          //  logger.error(textoError);
	          //}       
	      }
	      if(textoError != "")
	      {
	    	  error.value = textoError;
	      }
        } catch (Exception e) {
        	if (logger != null) {
        		logger.error("Error en guardarMetadatos:" + e.getMessage());
        	} else {
        		System.err.println("Error en guardarMetadatos "
        				+ e.getMessage());
        		e.printStackTrace();
        	}   
        	error.value = "Error en proceso de guardado de metadatos:"
        		+ e.getMessage();
        }
        return;
    }
    /* FINPETITRIBUTAS-88 MCMARCO ** 28/04/2020 ** Formato XML del expediente electrónico */

    /* INIPETITRIBUTAS-26 ENAVARRO ** 17/07/2020 ** Firma en tableta */
    /**
     * 
     * @param error
     * @param idArchivo
     * @param datosArchivo
     */
    public void vaciarFirmaBio(int idArchivo, Holder<String> datosArchivo, Holder<String> error) {
    	Logger logger = null;
        try {
          String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
          Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
          if (pref==null) {
            throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
          }
          logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
          logger.info("Petición Vaciar Firma biometrica");
          logger.info("idArchivo:" + idArchivo);
          
          Datos datos = new Datos(); 
          datos.vaciarFirmas(idArchivo, datosArchivo, error);
      
          logger.info("datosArchivo:" + datosArchivo.value);
          if(error.value!="" && error.value!=null) {
            logger.error("ERROR:" + error.value);
          }
          else {
        	  error.value = "1";
          }
          return;
        }
        catch (Exception e) {
          logger.error("Error eal intentar vaciar las firmas:" + e.getMessage());
          error.value= "Error en obtención de archivo digital:" + e.getMessage();
        }
    }
    /* FINPETITRIBUTAS-26 ENAVARRO ** 17/07/2020 ** Firma en tableta */

    // CRUBENCVS 41435.  Nueva operación para custodia de versión 
    /**
	 * 
	 * @param error
	 * @param hash
	 * @param codigoUsuario
	 * @param archivo
	 * @param identificador
	 * @param nombreFichero
	 * @param hashArchivo
	 * @param idArchivo
	 * @param tipoElemento
	 * @param csv
	 * @param comprimido
	 * @param metadatos
	 * @param firma
	 * @param idArchivoAnterior
	 */
	public void custodiaVersion(String codigoUsuario, String identificador,
			String tipoElemento, String nombreFichero, String comprimido,
			byte[] archivo, String hashArchivo, String metadatos,
			int idArchivoAnterior, FirmaType firma, Holder<Integer> idArchivo,
			Holder<String> csv, Holder<String> hash, Holder<String> error) {
		// Hemos de realizar las mismas operaciones que en 
		// la custodia, aunque luego llamaremos a la custodia de una nueva versión, 
		// luego he separado la funcionalidad de custodia en un nuevo método privado,
		// y llamaremos a custodia o a custodia de versión en función del parámetro de idArchivoAnterior
		Logger logger = null;
        try 
        {
      	  String idLlamada= (String) context.getMessageContext().get(Constantes.ID_LLAMADA);
      	  Preferencias pref= (Preferencias) context.getMessageContext().get(Constantes.PREFERENCIAS);
      	  if (pref==null) {
      		  throw new Exception ("No se han encontrado las preferencias en el contexto de la llamada");
      	  }
      	  logger= new Logger(idLlamada, pref.getAppLogDir(), pref.getAppLogFile());
      	  logger.info("Petición custodia versión");
      	  Datos datos = new Datos();
      	  DatosCustodia dc = prepararDatosCustodia(codigoUsuario, 
      			  								   identificador, 
      			  								   tipoElemento, 
      			  								   nombreFichero, 
      			  								   comprimido, 
      			  								   archivo, 
      			  								   hashArchivo,
      			  								   metadatos, 
      			  								   firma, 
      			  								   Integer.toString(idArchivoAnterior),
      			  								   idLlamada, 
      			  								   pref, 
      			  								   logger);		
      	
        datos.CustodiaVersion(dc.getCodigoUsuario(), 
        					  dc.getIdentificador(), 
                              dc.getTipoElemento(), 
                              dc.getNombreFichero(), 
                              dc.getComprimido(), 
                              dc.getContenido(), 
                              dc.getHashArchivo(), 
                              dc.getMetadatos(), 
                              dc.getFirmaCSV(),
                              dc.getFirmaCertificado(),
                              dc.getFirmaExterna(),
                              dc.getFechaValidezCertificadoFirma(),
                              dc.getCsv(), 
                              dc.getBaseCSV(), 
                              /* INIPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
                              dc.getHashFirma(), 
                              dc.getNombreFirmante(), 
                              dc.getFechaFirma(), 
                              dc.getIdTransac(), 
                              dc.getCargoUsua(), 
                              dc.getFormatoFirma(),
                              /* FINPETITRIBUTAS-5 ENAVARRO ** 22/10/2019 ** Compulsa */
                              dc.getIdArchivoAnterior(),
                              idArchivo, 
                              error);
            
        if(dc.esError()){
          error.value= dc.getError();
          logger.error("ERROR:" + error.value);
          csv.value="";
        }
        else
          csv.value=dc.getCsv();
        
        /* INIPETITRIBUTAS-5 ENAVARRO ** 21/12/2020 ** Compulsa */
        hash.value = dc.getHashArchivo();
        /* FINPETITRIBUTAS-5 ENAVARRO ** 21/12/2020 ** Compulsa */
        logger.info("Salida: idArchivo(" + idArchivo.value + "), csv(" + csv.value + ")");
        logger.info("FIN - Versión de Documento custodiada correctamente");
      } catch (Exception e)
      {
        if (logger!=null) {
          logger.error("Error en custodia de versión en Archivo Digital:" + e.getMessage());
          if (idArchivo.value!=null && idArchivo.value!=0) {
            logger.info("Salida: idArchivo(" + idArchivo.value + "), csv(" + csv.value + ")");
            logger.info("FIN - Documento custodiado correctamente");
          } else {
            logger.info("FIN - Documento no custodiado.");
          }
        }
        else {
          System.err.println ("Error en custodia de versión en Archivo Digital " + e.getMessage());
            e.printStackTrace();
        }
        error.value= "Error en proceso de archivo digital:" + e.getMessage();
      }
	}
}